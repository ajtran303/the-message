3.12.12
{
    "recommendations": [
        "sumneko.lua",
        "tomblind.local-lua-debugger-vscode",
        "editorconfig.editorconfig"
    ]
}
{
	"version": "0.2.0",
	"configurations": [
		{
			"type": "lua-local",
			"request": "launch",
			"name": "Debug",
			"program": {
				"command": "love"
			},
			"args": [
				".",
				"debug"
			],
		},
		{
			"type": "lua-local",
			"request": "launch",
			"name": "Release",
			"program": {
				"command": "love"
			},
			"args": [
				".",
			],
		},
	]
}
{
	"Lua.workspace.library": [
		"${3rd}/love2d/library",
		"lib"
	],
	"Lua.runtime.version": "LuaJIT",
	"Lua.workspace.checkThirdParty": false,
}
uniform float hueShift;
uniform float vignette;
uniform float desaturate;
uniform float aberration;
uniform float wobble;
uniform float time;

vec3 rgb2hsv(vec3 c) {
	vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
	vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
	vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
	vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec4 effect(vec4 color, Image tex, vec2 tc, vec2 sc) {
	vec2 uv = tc;

	// 5. Screen wobble — sine-based position offset, animated
	uv.x += sin(uv.y * 15.0 + time * 3.0) * wobble * 0.015;
	uv.y += cos(uv.x * 15.0 + time * 2.5) * wobble * 0.015;

	// 4. Chromatic aberration — split RGB channels
	float abOff = aberration * 0.008;
	float r = Texel(tex, uv + vec2(abOff, 0.0)).r;
	float g = Texel(tex, uv).g;
	float b = Texel(tex, uv - vec2(abOff, 0.0)).b;
	float a = Texel(tex, uv).a;
	vec4 pixel = vec4(r, g, b, a);

	// 1. Hue shift — rotate pixel colors
	vec3 hsv = rgb2hsv(pixel.rgb);
	hsv.x = fract(hsv.x + hueShift);
	pixel.rgb = hsv2rgb(hsv);

	// 3. Saturation drain — pull toward grayscale
	float grey = dot(pixel.rgb, vec3(0.299, 0.587, 0.114));
	pixel.rgb = mix(pixel.rgb, vec3(grey), desaturate);

	// 2. Vignette darkening — darken screen edges
	vec2 center = uv - 0.5;
	float dist = length(center);
	float vig = smoothstep(0.2, 0.8, dist) * vignette;
	pixel.rgb *= 1.0 - vig;

	return pixel * color;
}
local IS_DEBUG = os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" and arg[2] == "debug"
if IS_DEBUG then
	require("lldebugger").start()

	function love.errorhandler(msg)
		error(msg, 2)
	end
end

-- https://love2d.org/wiki/Config_Files
function love.conf(t)
	t.identity              = "the-message"
	t.appendidentity        = false
	t.version               = "11.4"
	t.console               = false
	t.accelerometerjoystick = false
	t.externalstorage       = false
	t.gammacorrect          = false

	t.audio.mic             = false
	t.audio.mixwithsystem   = true

	t.window.title          = "The Message"
	t.window.icon           = nil
	t.window.width          = 800
	t.window.height         = 600
	t.window.borderless     = false
	t.window.resizable      = false
	t.window.minwidth       = 1
	t.window.minheight      = 1
	t.window.fullscreen     = false
	t.window.fullscreentype = "desktop"
	t.window.vsync          = 1
	t.window.msaa           = 0
	t.window.depth          = nil
	t.window.stencil        = nil
	t.window.display        = 1
	t.window.highdpi        = false
	t.window.usedpiscale    = true
	t.window.x              = nil
	t.window.y              = nil

	t.modules.audio         = true
	t.modules.data          = true
	t.modules.event         = true
	t.modules.font          = true
	t.modules.graphics      = true
	t.modules.image         = true
	t.modules.joystick      = true
	t.modules.keyboard      = true
	t.modules.math          = true
	t.modules.mouse         = true
	t.modules.physics       = true
	t.modules.sound         = true
	t.modules.system        = true
	t.modules.thread        = true
	t.modules.timer         = true
	t.modules.touch         = true
	t.modules.video         = true
	t.modules.window        = true
end
-- AI tools used in development:
-- Claude (Anthropic) - design planning, specifications, code generation
-- All game design, architecture, and creative decisions by Jamie "AJ" Tran

-- Add src/ to require path
love.filesystem.setRequirePath("src/?.lua;src/?/init.lua;" .. love.filesystem.getRequirePath())

local states = require("states")
local player = require("player")
local campfires = require("campfires")
local symbols = require("symbols")
local glyphs = require("glyphs")
local postfx = require("postfx")
local spikes = require("spikes")
local environment = require("environment")
local audio = require("audio")

local GROUND_Y = 0

local function drawWorld()
	local screenW = love.graphics.getWidth()
	local screenH = love.graphics.getHeight()

	-- Sky
	love.graphics.setColor(0.15, 0.1, 0.2)
	love.graphics.rectangle("fill", 0, 0, screenW, GROUND_Y)

	-- Ground
	love.graphics.setColor(0.25, 0.2, 0.15)
	love.graphics.rectangle("fill", 0, GROUND_Y, screenW, screenH - GROUND_Y)

	-- Ground line
	love.graphics.setColor(0.4, 0.35, 0.25)
	love.graphics.line(0, GROUND_Y, screenW, GROUND_Y)
end

local cameraX = 0
local activeCampfire = nil
local transitionTimer = 0
local TRANSITION_DURATION = 1.5
local centerFade = 0
local CENTER_FADE_DURATION = 4
local titleFont = nil
local promptFont = nil
local tipFont = nil
local tipTimer = 0
local TIP_DURATION = 5
local TIP_FADE = 1.5
local currentTip = nil

local function showTip(text)
	currentTip = text
	tipTimer = TIP_DURATION
end

local function updateTip(dt)
	if tipTimer > 0 then
		tipTimer = tipTimer - dt
	end
end

local function drawTip()
	if not currentTip or tipTimer <= 0 then return end
	local alpha = tipTimer < TIP_FADE and tipTimer / TIP_FADE or 1
	local screenW = love.graphics.getWidth()
	local screenH = love.graphics.getHeight()
	love.graphics.setFont(tipFont)
	love.graphics.setColor(0.6, 0.55, 0.5, alpha * 0.8)
	local tw = tipFont:getWidth(currentTip)
	love.graphics.print(currentTip, (screenW - tw) / 2, 20)
end

local function resetGame()
	player.reset()
	campfires.reset()
	symbols.reset()
	environment.reset()
	audio.stopAll()
	cameraX = 0
	activeCampfire = nil
	centerFade = 0
end

function love.load()
	player.load()
	GROUND_Y = player.y + player.height
	campfires.load(GROUND_Y)
	glyphs.load()
	postfx.load()
	spikes.load(GROUND_Y)
	environment.load(GROUND_Y)
	audio.load()
	titleFont = love.graphics.newFont(48)
	promptFont = love.graphics.newFont(18)
	tipFont = love.graphics.newFont(20)

	states.register("start", {
		draw = function()
			local screenW = love.graphics.getWidth()
			local screenH = love.graphics.getHeight()

			-- Background
			love.graphics.setColor(0.08, 0.06, 0.1)
			love.graphics.rectangle("fill", 0, 0, screenW, screenH)

			-- Title
			love.graphics.setFont(titleFont)
			love.graphics.setColor(0.9, 0.85, 0.7)
			local title = "The Message"
			local tw = titleFont:getWidth(title)
			love.graphics.print(title, (screenW - tw) / 2, screenH / 2 - 60)

			-- Prompt
			love.graphics.setFont(promptFont)
			love.graphics.setColor(0.5, 0.45, 0.4)
			local prompt = "Press Enter to begin"
			local pw = promptFont:getWidth(prompt)
			love.graphics.print(prompt, (screenW - pw) / 2, screenH / 2 + 20)
		end,
		keypressed = function(key)
			if key == "return" then
				resetGame()
				showTip("Arrow keys to move  |  Esc to quit")
				states.set("walking")
			end
		end,
	})

	states.register("walking", {
		update = function(dt)
			player.update(dt)
			cameraX = player.x - love.graphics.getWidth() / 3

			local movingRight = love.keyboard.isDown("right", "d")
			local movingLeft = love.keyboard.isDown("left", "a")
			audio.updateFootsteps(dt, movingRight or movingLeft, movingRight)

			local progress = (symbols.getProgress().campfireIndex - 1) / 5
			environment.update(dt, cameraX, progress)

			local idx = campfires.checkProximity(player.x)
			if idx then
				activeCampfire = idx
				symbols.activate(activeCampfire)
				showTip("Click to swap symbols  |  Enter to confirm")
				states.set("campfire")
			end
			updateTip(dt)
		end,
		draw = function()
			local progress = (symbols.getProgress().campfireIndex - 1) / 5
			local time = love.timer.getTime()
			drawWorld()
			environment.drawGround(cameraX, progress)
			environment.drawSky(cameraX, progress, time)
			spikes.draw(cameraX)
			environment.drawCampfireGlow(cameraX, campfires.getList())
			campfires.draw(cameraX)
			player.draw(cameraX)
			drawTip()
		end,
		keypressed = function(key)
			if key == "escape" then
				resetGame()
				states.set("start")
			end
		end,
	})

	states.register("transition", {
		update = function(dt)
			local progress = (symbols.getProgress().campfireIndex - 1) / 5
			environment.update(dt, cameraX, progress)
			transitionTimer = transitionTimer - dt
			if transitionTimer <= 0 then
				if activeCampfire >= 5 then
					centerFade = 0
					audio.startCenter()
					states.set("center")
				else
					activeCampfire = nil
					states.set("walking")
				end
			end
		end,
		draw = function()
			local progress = (symbols.getProgress().campfireIndex - 1) / 5
			local time = love.timer.getTime()
			drawWorld()
			environment.drawGround(cameraX, progress)
			environment.drawSky(cameraX, progress, time)
			spikes.draw(cameraX)
			environment.drawCampfireGlow(cameraX, campfires.getList())
			campfires.draw(cameraX)
			player.draw(cameraX)
		end,
	})

	states.register("center", {
		update = function(dt)
			environment.update(dt, cameraX, 1)
			if centerFade < 1 then
				centerFade = math.min(1, centerFade + dt / CENTER_FADE_DURATION)
			end
			audio.updateCenter(dt)
		end,
		draw = function()
			local time = love.timer.getTime()
			drawWorld()
			environment.drawGround(cameraX, 1)
			environment.drawSky(cameraX, 1, time)
			spikes.draw(cameraX)
			campfires.draw(cameraX)
			player.draw(cameraX)

			-- Fade to black overlay
			love.graphics.setColor(0, 0, 0, centerFade)
			love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())
		end,
		keypressed = function(key)
			if key == "escape" then
				resetGame()
				states.set("start")
			end
		end,
	})

	states.register("campfire", {
		update = function(dt)
			local progress = (symbols.getProgress().campfireIndex - 1) / 5
			environment.update(dt, cameraX, progress)
		end,
		draw = function()
			local progress = (symbols.getProgress().campfireIndex - 1) / 5
			local time = love.timer.getTime()
			drawWorld()
			environment.drawGround(cameraX, progress)
			environment.drawSky(cameraX, progress, time)
			spikes.draw(cameraX)
			environment.drawCampfireGlow(cameraX, campfires.getList())
			campfires.draw(cameraX)
			player.draw(cameraX)
			glyphs.draw(symbols.getActive(), symbols.getSelected())
			drawTip()
		end,
		keypressed = function(key)
			if key == "return" then
				audio.playClick()
				symbols.confirm(activeCampfire)
				campfires.markVisited(activeCampfire)
				currentTip = nil
				transitionTimer = TRANSITION_DURATION
				states.set("transition")
			elseif key == "escape" then
				states.set("start")
			end
		end,
		mousepressed = function(x, y, button)
			if button ~= 1 then return end
			local active = symbols.getActive()
			if not active then return end
			local hit = glyphs.hitTest(#active, x, y)
			if hit then
				audio.playClick()
				symbols.select(hit)
			end
		end,
	})
end

function love.update(dt)
	postfx.update(dt)
	campfires.update(dt)
	states.update(dt)
end

function love.draw()
	postfx.beginDraw()
	states.draw()
	postfx.endDraw(symbols.getProgress().shaderParams)
end

function love.keypressed(key)
	states.keypressed(key)
end

function love.mousepressed(x, y, button)
	states.mousepressed(x, y, button)
end
local audio = {}

local SAMPLE_RATE = 44100

local heartbeatSource = nil
local geigerSource = nil
local footstepSource = nil
local clickSource = nil

local function makeSoundData(duration, generator)
	local samples = math.floor(SAMPLE_RATE * duration)
	local data = love.sound.newSoundData(samples, SAMPLE_RATE, 16, 1)
	for i = 0, samples - 1 do
		local t = i / SAMPLE_RATE
		data:setSample(i, generator(t, duration))
	end
	return data
end

local function generateHeartbeat()
	-- Two-thump heartbeat pattern, loopable ~1.1 sec
	local duration = 1.1
	return makeSoundData(duration, function(t)
		-- First thump at t=0, second at t=0.18
		local s = 0
		for _, offset in ipairs({0.0, 0.18}) do
			local dt = t - offset
			if dt >= 0 and dt < 0.12 then
				local env = math.sin(dt / 0.12 * math.pi)
				env = env * env
				s = s + math.sin(dt * math.pi * 2 * 45) * env * 0.6
				s = s + math.sin(dt * math.pi * 2 * 30) * env * 0.3
			end
		end
		return math.max(-1, math.min(1, s))
	end)
end

local function generateGeiger()
	-- Random clicks over ~3 seconds, loopable
	local duration = 3.0
	local samples = math.floor(SAMPLE_RATE * duration)
	local data = love.sound.newSoundData(samples, SAMPLE_RATE, 16, 1)

	-- Pre-generate click positions
	math.randomseed(42)
	local clicks = {}
	local pos = 0
	while pos < samples do
		clicks[#clicks + 1] = pos
		-- Random gap: 400-4000 samples (irregular rhythm)
		pos = pos + math.random(400, 4000)
	end

	for i = 0, samples - 1 do
		local s = 0
		for _, clickPos in ipairs(clicks) do
			local d = i - clickPos
			if d >= 0 and d < 120 then
				local env = 1 - d / 120
				env = env * env
				s = s + (math.random() * 2 - 1) * env * 0.4
			end
		end
		data:setSample(i, math.max(-1, math.min(1, s)))
	end
	math.randomseed(os.time())
	return data
end

local function generateFootstep()
	-- Short crunch/thud
	local duration = 0.1
	return makeSoundData(duration, function(t, dur)
		local env = 1 - t / dur
		env = env * env * env
		local noise = math.random() * 2 - 1
		local thud = math.sin(t * math.pi * 2 * 80) * env * 0.3
		return math.max(-1, math.min(1, noise * env * 0.25 + thud))
	end)
end

local function generateClick()
	-- Tiny UI tick
	local duration = 0.04
	return makeSoundData(duration, function(t, dur)
		local env = 1 - t / dur
		env = env * env
		return math.sin(t * math.pi * 2 * 800) * env * 0.3
	end)
end

function audio.load()
	heartbeatSource = love.audio.newSource(generateHeartbeat(), "static")
	heartbeatSource:setLooping(true)
	heartbeatSource:setVolume(0)

	geigerSource = love.audio.newSource(generateGeiger(), "static")
	geigerSource:setLooping(true)
	geigerSource:setVolume(0)

	footstepSource = love.audio.newSource(generateFootstep(), "static")
	footstepSource:setLooping(false)

	clickSource = love.audio.newSource(generateClick(), "static")
	clickSource:setLooping(false)
end

-- Footstep system
local footstepTimer = 0
local footstepInterval = 0.45
local footstepPlaying = false

function audio.updateFootsteps(dt, isWalking, movingRight)
	if isWalking then
		footstepInterval = movingRight and 0.4 or 0.6
		footstepTimer = footstepTimer + dt
		if footstepTimer >= footstepInterval then
			footstepTimer = footstepTimer - footstepInterval
			footstepSource:stop()
			footstepSource:setPitch(0.8 + math.random() * 0.4)
			footstepSource:setVolume(0.3)
			footstepSource:play()
		end
		footstepPlaying = true
	else
		footstepTimer = 0
		footstepPlaying = false
	end
end

-- Center ending audio phases
local centerTimer = 0
local PHASE1_END = 6    -- heartbeat only
local PHASE2_END = 20   -- heartbeat + geiger
-- After phase 2: heartbeat fades, geiger alone

function audio.startCenter()
	centerTimer = 0
	heartbeatSource:setVolume(0.7)
	heartbeatSource:play()
	geigerSource:setVolume(0)
	geigerSource:play()
end

function audio.updateCenter(dt)
	centerTimer = centerTimer + dt

	if centerTimer < PHASE1_END then
		-- Phase 1: heartbeat only
		heartbeatSource:setVolume(0.7)
		geigerSource:setVolume(0)
	elseif centerTimer < PHASE2_END then
		-- Phase 2: geiger fades in
		local t = (centerTimer - PHASE1_END) / (PHASE2_END - PHASE1_END)
		heartbeatSource:setVolume(0.7)
		geigerSource:setVolume(t * 0.5)
	else
		-- Phase 3: heartbeat fades to quiet, geiger alone
		local t = math.min(1, (centerTimer - PHASE2_END) / 10)
		heartbeatSource:setVolume(0.7 * (1 - t) * (1 - t))
		geigerSource:setVolume(0.5)
	end
end

function audio.stopAll()
	heartbeatSource:stop()
	geigerSource:stop()
	footstepSource:stop()
	footstepTimer = 0
	centerTimer = 0
end

function audio.playClick()
	clickSource:stop()
	clickSource:play()
end

return audio
local campfires = {}

local PROXIMITY = 40

-- Fibonacci spacing: 1, 1, 2, 3, 5
local SPACING = {1, 1, 2, 3, 5}

local list = {}
local groundY = 0
local elapsed = 0

function campfires.load(playerGroundY)
	groundY = playerGroundY
	local screenW = love.graphics.getWidth()
	local x = screenW
	list = {}
	for i = 1, 5 do
		list[i] = { x = x, visited = false }
		if i < 5 then
			x = x + SPACING[i + 1] * screenW
		end
	end
end

function campfires.reset()
	for _, cf in ipairs(list) do
		cf.visited = false
	end
	elapsed = 0
end

function campfires.update(dt)
	elapsed = elapsed + dt
end

function campfires.getList()
	return list
end

function campfires.checkProximity(playerX)
	for i, cf in ipairs(list) do
		if not cf.visited and math.abs(playerX - cf.x) < PROXIMITY then
			return i
		end
	end
	return nil
end

function campfires.markVisited(index)
	list[index].visited = true
end

local function drawFlame(sx, sy, dim, t)
	-- Logs
	love.graphics.setColor(0.35 * dim, 0.18 * dim, 0.08 * dim)
	love.graphics.polygon("fill", sx - 10, sy, sx - 2, sy - 4, sx + 6, sy)
	love.graphics.polygon("fill", sx - 6, sy, sx + 2, sy - 3, sx + 10, sy)

	-- Flame layers (animated)
	local flicker1 = math.sin(t * 6) * 2
	local flicker2 = math.cos(t * 8.5) * 1.5
	local flicker3 = math.sin(t * 11) * 1

	-- Outer glow
	love.graphics.setColor(1 * dim, 0.3 * dim, 0.05 * dim, 0.3 * dim)
	love.graphics.polygon("fill",
		sx - 8, sy,
		sx + flicker1, sy - 20 + flicker2,
		sx + 8, sy
	)

	-- Mid flame
	love.graphics.setColor(1 * dim, 0.5 * dim, 0.1 * dim, 0.7 * dim)
	love.graphics.polygon("fill",
		sx - 5, sy - 2,
		sx + flicker2, sy - 16 + flicker3,
		sx + 5, sy - 2
	)

	-- Inner flame
	love.graphics.setColor(1 * dim, 0.85 * dim, 0.3 * dim, 0.9 * dim)
	love.graphics.polygon("fill",
		sx - 3, sy - 3,
		sx + flicker3, sy - 10 + flicker1 * 0.5,
		sx + 3, sy - 3
	)

	-- Ember particles
	love.graphics.setColor(1 * dim, 0.6 * dim, 0.1 * dim, 0.6 * dim)
	for j = 1, 3 do
		local et = t * 3 + j * 2.1
		local ex = sx + math.sin(et * 1.7 + j) * 4
		local ey = sy - 8 - math.fmod(et * 5, 18)
		local ea = 1 - math.fmod(et * 5, 18) / 18
		love.graphics.setColor(1 * dim, 0.5 * dim, 0.1 * dim, ea * 0.5 * dim)
		love.graphics.circle("fill", ex, ey, 1)
	end
end

local function drawAshes(sx, sy, dim)
	-- Dead campfire: charred logs and ash
	love.graphics.setColor(0.15 * dim, 0.1 * dim, 0.08 * dim)
	love.graphics.polygon("fill", sx - 10, sy, sx - 2, sy - 3, sx + 6, sy)
	love.graphics.polygon("fill", sx - 6, sy, sx + 2, sy - 2, sx + 10, sy)

	-- Ash pile
	love.graphics.setColor(0.25 * dim, 0.2 * dim, 0.18 * dim)
	love.graphics.ellipse("fill", sx, sy - 2, 7, 3)
end

function campfires.draw(cameraX)
	local screenW = love.graphics.getWidth()

	for i, cf in ipairs(list) do
		local sx = cf.x - cameraX
		if sx > -30 and sx < screenW + 30 then
			local dim = 1.0 - (i - 1) * 0.18
			if cf.visited then
				drawAshes(sx, groundY, dim)
			else
				drawFlame(sx, groundY, dim, elapsed + i * 3.7)
			end
		end
	end
end

return campfires
local environment = {}

local groundY = 0
local screenW = 0
local worldEnd = 0

-- Dust particles
local dust = {}
local DUST_COUNT = 50

-- Stars
local stars = {}
local STAR_COUNT = 100

-- Ground cracks
local cracks = {}

function environment.load(playerGroundY)
	groundY = playerGroundY
	screenW = love.graphics.getWidth()
	worldEnd = screenW * 13

	environment.reset()
end

function environment.reset()
	-- Generate dust pool
	dust = {}
	for i = 1, DUST_COUNT do
		dust[i] = {
			x = math.random() * worldEnd,
			y = math.random() * groundY,
			speed = 8 + math.random() * 12,
			size = 1 + math.random() * 1.5,
			alpha = 0.1 + math.random() * 0.15,
			drift = math.random() * math.pi * 2,
		}
	end

	-- Generate stars
	stars = {}
	local skyLimit = groundY * 0.6
	for i = 1, STAR_COUNT do
		stars[i] = {
			x = math.random() * worldEnd,
			y = math.random() * skyLimit,
			brightness = 0.3 + math.random() * 0.7,
			twinkleSpeed = 1.5 + math.random() * 3,
			twinklePhase = math.random() * math.pi * 2,
			size = 0.5 + math.random() * 1,
		}
	end

	-- Generate ground cracks
	cracks = {}
	local crackX = worldEnd * 0.3
	while crackX < worldEnd do
		local t = crackX / worldEnd
		-- More cracks toward center
		local gap = 80 - 60 * t
		local segCount = 2 + math.floor(math.random() * 3)
		local segs = {}
		local cx, cy = crackX + (math.random() - 0.5) * gap * 0.4, groundY
		for s = 1, segCount do
			local nx = cx + 4 + math.random() * 12
			local ny = groundY + (math.random() - 0.5) * 6
			segs[s] = {x1 = cx, y1 = cy, x2 = nx, y2 = ny}
			cx, cy = nx, ny
		end
		cracks[#cracks + 1] = {
			x = crackX,
			segments = segs,
			t = t,
		}
		crackX = crackX + gap + math.random() * gap * 0.5
	end
end

function environment.update(dt, cameraX, progress)
	local speedMul = 1 + progress * 2

	for _, d in ipairs(dust) do
		d.drift = d.drift + dt * 0.7
		d.x = d.x + d.speed * speedMul * dt
		d.y = d.y + math.sin(d.drift) * 8 * dt

		-- Recycle when offscreen right of camera view
		if d.x > cameraX + screenW + 20 then
			d.x = cameraX - 20 - math.random() * 40
			d.y = math.random() * groundY
		-- Also recycle if way behind camera
		elseif d.x < cameraX - 60 then
			d.x = cameraX + screenW + math.random() * 40
			d.y = math.random() * groundY
		end
	end
end

function environment.drawSky(cameraX, progress, time)
	local sw = screenW

	-- Stars (fade with progress)
	local starAlpha = 1 - progress
	if starAlpha > 0 then
		for _, s in ipairs(stars) do
			local sx = s.x - cameraX
			if sx > -2 and sx < sw + 2 then
				local twinkle = 0.7 + 0.3 * math.sin(time * s.twinkleSpeed + s.twinklePhase)
				local a = s.brightness * twinkle * starAlpha
				love.graphics.setColor(0.9, 0.85, 0.8, a)
				love.graphics.circle("fill", sx, s.y, s.size)
			end
		end
	end

	-- Dust particles
	local dustAlpha = 0.5 + progress * 0.5
	for _, d in ipairs(dust) do
		local sx = d.x - cameraX
		if sx > -5 and sx < sw + 5 then
			love.graphics.setColor(0.6, 0.55, 0.45, d.alpha * dustAlpha)
			love.graphics.circle("fill", sx, d.y, d.size)
		end
	end
end

function environment.drawGround(cameraX, progress)
	local sw = screenW

	-- Ground cracks (alpha ramps with progress)
	if progress > 0.1 then
		for _, c in ipairs(cracks) do
			local cx = c.x - cameraX
			if cx > -40 and cx < sw + 40 then
				local a = 0.15 + 0.45 * progress * c.t
				love.graphics.setColor(0.12, 0.08, 0.05, a)
				love.graphics.setLineWidth(1)
				for _, seg in ipairs(c.segments) do
					love.graphics.line(
						seg.x1 - cameraX, seg.y1,
						seg.x2 - cameraX, seg.y2
					)
				end
			end
		end
	end
end

function environment.drawCampfireGlow(cameraX, campfireList)
	local sw = screenW

	for i, cf in ipairs(campfireList) do
		if not cf.visited then
			local sx = cf.x - cameraX
			if sx > -100 and sx < sw + 100 then
				local dim = 1.0 - (i - 1) * 0.18
				-- Concentric ellipses for soft glow
				local layers = {
					{rx = 70, ry = 12, a = 0.06},
					{rx = 50, ry = 9, a = 0.10},
					{rx = 30, ry = 6, a = 0.15},
				}
				for _, l in ipairs(layers) do
					love.graphics.setColor(1, 0.6, 0.15, l.a * dim)
					love.graphics.ellipse("fill", sx, groundY + 2, l.rx, l.ry)
				end
			end
		end
	end
end

return environment
local glyphs = {}

local canvases = {}
local SLOT_SIZE = 64
local PADDING = 12
local SYM_SIZE = 48

local function drawSigil(id)
	local c = love.graphics.newCanvas(SYM_SIZE, SYM_SIZE)
	love.graphics.setCanvas(c)
	love.graphics.clear(0, 0, 0, 0)
	love.graphics.setColor(1, 1, 1)
	love.graphics.setLineWidth(1.5)

	local cx, cy = SYM_SIZE / 2, SYM_SIZE / 2
	local r = SYM_SIZE / 2 - 4

	if id == 1 then
		-- Pentagram
		local pts = {}
		for i = 0, 4 do
			local a = math.rad(-90 + i * 72)
			pts[#pts + 1] = cx + math.cos(a) * r
			pts[#pts + 1] = cy + math.sin(a) * r
		end
		local order = {1, 3, 5, 2, 4, 1}
		for i = 1, #order - 1 do
			local a, b = order[i], order[i + 1]
			love.graphics.line(pts[a*2-1], pts[a*2], pts[b*2-1], pts[b*2])
		end

	elseif id == 2 then
		-- Concentric circles
		love.graphics.circle("line", cx, cy, r)
		love.graphics.circle("line", cx, cy, r * 0.6)
		love.graphics.circle("line", cx, cy, r * 0.25)

	elseif id == 3 then
		-- Eye of providence
		love.graphics.polygon("line", cx, cy - r * 0.6, cx - r, cy + r * 0.3, cx + r, cy + r * 0.3)
		love.graphics.circle("line", cx, cy, r * 0.3)
		love.graphics.circle("fill", cx, cy, r * 0.12)

	elseif id == 4 then
		-- Spiral
		local pts = {}
		for i = 0, 60 do
			local t = i / 60
			local a = t * math.pi * 4
			local sr = t * r
			pts[#pts + 1] = cx + math.cos(a) * sr
			pts[#pts + 1] = cy + math.sin(a) * sr
		end
		love.graphics.line(pts)

	elseif id == 5 then
		-- Cross with circle
		love.graphics.circle("line", cx, cy, r)
		love.graphics.line(cx, cy - r, cx, cy + r)
		love.graphics.line(cx - r, cy, cx + r, cy)

	elseif id == 6 then
		-- Crescent moon
		love.graphics.arc("line", "open", cx - 4, cy, r, -math.pi/2, math.pi/2)
		love.graphics.arc("line", "open", cx + 6, cy, r * 0.7, -math.pi/2, math.pi/2)

	elseif id == 7 then
		-- Triangle up
		love.graphics.polygon("line", cx, cy - r, cx - r, cy + r * 0.7, cx + r, cy + r * 0.7)
		love.graphics.line(cx - r * 0.6, cy + r * 0.1, cx + r * 0.6, cy + r * 0.1)

	elseif id == 8 then
		-- Inverted triangle
		love.graphics.polygon("line", cx, cy + r, cx - r, cy - r * 0.7, cx + r, cy - r * 0.7)
		love.graphics.line(cx - r * 0.6, cy - r * 0.1, cx + r * 0.6, cy - r * 0.1)

	elseif id == 9 then
		-- Hexagon
		local hex = {}
		for i = 0, 5 do
			local a = math.rad(-90 + i * 60)
			hex[#hex + 1] = cx + math.cos(a) * r
			hex[#hex + 1] = cy + math.sin(a) * r
		end
		love.graphics.polygon("line", hex)

	elseif id == 10 then
		-- Ankh
		love.graphics.circle("line", cx, cy - r * 0.35, r * 0.35)
		love.graphics.line(cx, cy, cx, cy + r)
		love.graphics.line(cx - r * 0.4, cy + r * 0.3, cx + r * 0.4, cy + r * 0.3)

	elseif id == 11 then
		-- Triple moon
		love.graphics.circle("line", cx, cy, r * 0.4)
		love.graphics.arc("line", "open", cx - r * 0.5, cy, r * 0.7, -math.pi/2, math.pi/2)
		love.graphics.arc("line", "open", cx + r * 0.5, cy, r * 0.7, math.pi/2, math.pi * 1.5)

	elseif id == 12 then
		-- Serpent S
		love.graphics.arc("line", "open", cx, cy - r * 0.3, r * 0.4, math.pi, 0)
		love.graphics.arc("line", "open", cx, cy + r * 0.3, r * 0.4, 0, math.pi)
		love.graphics.circle("fill", cx + r * 0.4, cy - r * 0.3, 2)

	elseif id == 13 then
		-- Radiant sun
		love.graphics.circle("line", cx, cy, r * 0.35)
		for i = 0, 7 do
			local a = i * math.pi / 4
			love.graphics.line(
				cx + math.cos(a) * r * 0.45, cy + math.sin(a) * r * 0.45,
				cx + math.cos(a) * r, cy + math.sin(a) * r
			)
		end

	elseif id == 14 then
		-- Diamond nested
		local function diamond(s)
			love.graphics.polygon("line", cx, cy - s, cx + s, cy, cx, cy + s, cx - s, cy)
		end
		diamond(r)
		diamond(r * 0.55)

	elseif id == 15 then
		-- Arrow down with crossbar
		love.graphics.line(cx, cy - r, cx, cy + r)
		love.graphics.line(cx - r * 0.5, cy + r * 0.4, cx, cy + r, cx + r * 0.5, cy + r * 0.4)
		love.graphics.line(cx - r * 0.4, cy - r * 0.2, cx + r * 0.4, cy - r * 0.2)
		love.graphics.line(cx - r * 0.3, cy + r * 0.05, cx + r * 0.3, cy + r * 0.05)

	elseif id == 16 then
		-- Infinity / lemniscate
		local pts = {}
		for i = 0, 60 do
			local t = (i / 60) * math.pi * 2
			local scale = r * 0.9 / (1 + math.sin(t) * math.sin(t))
			pts[#pts + 1] = cx + math.cos(t) * scale
			pts[#pts + 1] = cy + math.sin(t) * math.cos(t) * scale * 0.6
		end
		love.graphics.line(pts)

	elseif id == 17 then
		-- Three vertical lines with dots
		for i = -1, 1 do
			local lx = cx + i * r * 0.4
			love.graphics.line(lx, cy - r * 0.7, lx, cy + r * 0.7)
			love.graphics.circle("fill", lx, cy - r * 0.85, 2)
		end

	elseif id == 18 then
		-- Hourglass
		love.graphics.polygon("line", cx - r * 0.7, cy - r, cx + r * 0.7, cy - r, cx, cy)
		love.graphics.polygon("line", cx - r * 0.7, cy + r, cx + r * 0.7, cy + r, cx, cy)

	elseif id == 19 then
		-- Trident
		love.graphics.line(cx, cy + r, cx, cy - r * 0.5)
		love.graphics.arc("line", "open", cx - r * 0.35, cy - r * 0.3, r * 0.35, math.pi, 0)
		love.graphics.arc("line", "open", cx + r * 0.35, cy - r * 0.3, r * 0.35, math.pi, 0)
		love.graphics.line(cx - r * 0.7, cy - r * 0.3, cx - r * 0.7, cy - r)
		love.graphics.line(cx, cy - r * 0.65, cx, cy - r)
		love.graphics.line(cx + r * 0.7, cy - r * 0.3, cx + r * 0.7, cy - r)

	elseif id == 20 then
		-- Void circle with dot
		love.graphics.circle("line", cx, cy, r)
		love.graphics.circle("fill", cx, cy, 3)
	end

	love.graphics.setCanvas()
	return c
end

function glyphs.load()
	canvases = {}
	for i = 1, 20 do
		canvases[i] = drawSigil(i)
	end
end

function glyphs.getSlotSize()
	return SLOT_SIZE
end

function glyphs.getPadding()
	return PADDING
end

function glyphs.draw(symbolIds, selectedIndex)
	if not symbolIds then return end

	local count = #symbolIds
	local totalWidth = count * SLOT_SIZE + (count - 1) * PADDING
	local screenW = love.graphics.getWidth()
	local screenH = love.graphics.getHeight()
	local startX = (screenW - totalWidth) / 2
	local y = screenH / 2 - SLOT_SIZE / 2

	for i, id in ipairs(symbolIds) do
		local x = startX + (i - 1) * (SLOT_SIZE + PADDING)

		-- Slot background
		if i == selectedIndex then
			love.graphics.setColor(0.8, 0.6, 0.2)
		else
			love.graphics.setColor(0.2, 0.2, 0.2)
		end
		love.graphics.rectangle("fill", x, y, SLOT_SIZE, SLOT_SIZE, 4, 4)

		-- Slot border
		if i == selectedIndex then
			love.graphics.setColor(1, 0.85, 0.4)
		else
			love.graphics.setColor(0.5, 0.5, 0.5)
		end
		love.graphics.rectangle("line", x, y, SLOT_SIZE, SLOT_SIZE, 4, 4)

		-- Symbol canvas
		love.graphics.setColor(1, 1, 1)
		local canvas = canvases[id]
		if canvas then
			local ox = x + (SLOT_SIZE - SYM_SIZE) / 2
			local oy = y + (SLOT_SIZE - SYM_SIZE) / 2
			love.graphics.draw(canvas, ox, oy)
		end
	end
end

function glyphs.hitTest(symbolCount, mx, my)
	local totalWidth = symbolCount * SLOT_SIZE + (symbolCount - 1) * PADDING
	local screenW = love.graphics.getWidth()
	local screenH = love.graphics.getHeight()
	local startX = (screenW - totalWidth) / 2
	local y = screenH / 2 - SLOT_SIZE / 2

	for i = 1, symbolCount do
		local x = startX + (i - 1) * (SLOT_SIZE + PADDING)
		if mx >= x and mx <= x + SLOT_SIZE and my >= y and my <= y + SLOT_SIZE then
			return i
		end
	end
	return nil
end

return glyphs
local player = {}

local SPEED_RIGHT = 100
local SPEED_LEFT = 50
local WIDTH = 16
local HEIGHT = 32

player.x = 0
player.y = 0
player.width = WIDTH
player.height = HEIGHT

local walkTimer = 0

function player.load()
	local screenH = love.graphics.getHeight()
	player.y = screenH - HEIGHT - 40
end

function player.reset()
	player.x = 0
	walkTimer = 0
end

function player.update(dt)
	if love.keyboard.isDown("right", "d") then
		player.x = player.x + SPEED_RIGHT * dt
		walkTimer = walkTimer + dt * 8
	elseif love.keyboard.isDown("left", "a") then
		player.x = player.x - SPEED_LEFT * dt
		walkTimer = walkTimer + dt * 5
	else
		walkTimer = 0
	end
end

function player.draw(cameraX)
	local sx = player.x - cameraX
	local sy = player.y
	local bob = math.sin(walkTimer) * 1.5

	-- Head
	love.graphics.setColor(0.85, 0.8, 0.7)
	love.graphics.circle("fill", sx + WIDTH / 2, sy + 5 + bob, 5)

	-- Body
	love.graphics.setColor(0.6, 0.55, 0.5)
	love.graphics.setLineWidth(2)
	love.graphics.line(sx + WIDTH / 2, sy + 10 + bob, sx + WIDTH / 2, sy + 22 + bob)

	-- Arms
	local armSwing = math.sin(walkTimer) * 3
	love.graphics.line(sx + WIDTH / 2, sy + 14 + bob, sx + WIDTH / 2 - 5, sy + 19 + bob + armSwing)
	love.graphics.line(sx + WIDTH / 2, sy + 14 + bob, sx + WIDTH / 2 + 5, sy + 19 + bob - armSwing)

	-- Legs
	local legSwing = math.sin(walkTimer) * 4
	love.graphics.line(sx + WIDTH / 2, sy + 22 + bob, sx + WIDTH / 2 - 4, sy + HEIGHT + legSwing)
	love.graphics.line(sx + WIDTH / 2, sy + 22 + bob, sx + WIDTH / 2 + 4, sy + HEIGHT - legSwing)

	love.graphics.setLineWidth(1)
end

return player
local postfx = {}

local canvas = nil
local shader = nil
local elapsed = 0

function postfx.load()
	canvas = love.graphics.newCanvas()
	shader = love.graphics.newShader("assets/shaders/uber.glsl")
end

function postfx.beginDraw()
	love.graphics.setCanvas(canvas)
	love.graphics.clear()
end

function postfx.update(dt)
	elapsed = elapsed + dt
end

function postfx.endDraw(shaderParams)
	love.graphics.setCanvas()

	shader:send("hueShift", shaderParams[1])
	shader:send("vignette", shaderParams[2])
	shader:send("desaturate", shaderParams[3])
	shader:send("aberration", shaderParams[4])
	shader:send("wobble", shaderParams[5])
	shader:send("time", elapsed)

	love.graphics.setShader(shader)
	love.graphics.setColor(1, 1, 1)
	love.graphics.draw(canvas)
	love.graphics.setShader()
end

return postfx
local spikes = {}

local list = {}
local groundY = 0

function spikes.load(playerGroundY)
	groundY = playerGroundY
	list = {}

	local screenW = love.graphics.getWidth()
	local worldEnd = screenW * 13
	local x = screenW * 0.5

	while x < worldEnd do
		-- Progress 0..1 across the world
		local t = x / worldEnd

		-- Density increases toward center: gap shrinks from 120 to 20
		local gap = 120 - 100 * t * t

		-- Height increases toward center
		local minH = 20 + 120 * t
		local maxH = 60 + 300 * t
		local h = minH + math.random() * (maxH - minH)

		-- Width narrows slightly toward center
		local w = 6 + math.random() * 10 * (1 - t * 0.5)

		-- Slight horizontal jitter
		local jitter = (math.random() - 0.5) * gap * 0.3

		list[#list + 1] = {
			x = x + jitter,
			height = h,
			width = w,
			-- Fade in: visible early, solid late
			alpha = 0.25 + 0.65 * t,
		}

		x = x + gap + math.random() * gap * 0.5
	end
end

function spikes.draw(cameraX)
	local screenW = love.graphics.getWidth()

	for _, s in ipairs(list) do
		local sx = s.x - cameraX
		-- Cull offscreen
		if sx > -s.width and sx < screenW + s.width then
			love.graphics.setColor(0.05, 0.02, 0.05, s.alpha)
			-- Triangle spike rising from ground
			love.graphics.polygon("fill",
				sx - s.width / 2, groundY,
				sx, groundY - s.height,
				sx + s.width / 2, groundY
			)
		end
	end
end

return spikes
local states = {}

local current = "start"

local handlers = {
	start = {},
	walking = {},
	campfire = {},
	transition = {},
	center = {},
}

function states.get()
	return current
end

function states.set(name)
	assert(handlers[name], "Invalid state: " .. tostring(name))
	current = name
end

function states.register(name, fns)
	assert(handlers[name], "Invalid state: " .. tostring(name))
	handlers[name] = fns
end

function states.update(dt)
	local h = handlers[current]
	if h.update then h.update(dt) end
end

function states.draw()
	local h = handlers[current]
	if h.draw then h.draw() end
end

function states.keypressed(key)
	local h = handlers[current]
	if h.keypressed then h.keypressed(key) end
end

function states.mousepressed(x, y, button)
	local h = handlers[current]
	if h.mousepressed then h.mousepressed(x, y, button) end
end

return states
local symbols = {}

local TOTAL_SYMBOLS = 20
local COUNTS = {3, 3, 4, 4, 5}

local progress = {
	campfireIndex = 1,
	shaderParams = {0, 0, 0, 0, 0},
}

local activeSymbols = nil
local selectedIndex = nil
local campfireSymbols = nil

local function shuffle()
	-- Build pool of all symbol ids
	local pool = {}
	for i = 1, TOTAL_SYMBOLS do
		pool[i] = i
	end
	-- Fisher-Yates shuffle
	for i = TOTAL_SYMBOLS, 2, -1 do
		local j = math.random(1, i)
		pool[i], pool[j] = pool[j], pool[i]
	end
	-- Deal from shuffled pool into campfire sets
	campfireSymbols = {}
	local idx = 1
	for cf = 1, 5 do
		local set = {}
		for s = 1, COUNTS[cf] do
			set[s] = pool[idx]
			idx = idx + 1
		end
		campfireSymbols[cf] = { symbols = set, effect = cf }
	end
end

function symbols.activate(campfireIndex)
	local data = campfireSymbols[campfireIndex]
	activeSymbols = {}
	for i, v in ipairs(data.symbols) do
		activeSymbols[i] = v
	end
	selectedIndex = nil
end

function symbols.getActive()
	return activeSymbols
end

function symbols.getSelected()
	return selectedIndex
end

function symbols.select(index)
	if not activeSymbols then return end
	if index < 1 or index > #activeSymbols then return end

	if selectedIndex == nil then
		selectedIndex = index
	elseif selectedIndex == index then
		selectedIndex = nil
	else
		activeSymbols[selectedIndex], activeSymbols[index] = activeSymbols[index], activeSymbols[selectedIndex]
		selectedIndex = nil
	end
end

function symbols.confirm(campfireIndex)
	if not activeSymbols then return end
	local param = activeSymbols[1] / TOTAL_SYMBOLS
	progress.shaderParams[campfireIndex] = param
	progress.campfireIndex = campfireIndex + 1
	activeSymbols = nil
	selectedIndex = nil
end

function symbols.reset()
	progress.campfireIndex = 1
	progress.shaderParams = {0, 0, 0, 0, 0}
	activeSymbols = nil
	selectedIndex = nil
	shuffle()
end

function symbols.getProgress()
	return progress
end

-- Initial shuffle
shuffle()

return symbols
